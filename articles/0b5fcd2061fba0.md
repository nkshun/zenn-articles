---
title: "たぶんsetInterval内から外にエラーthrowはできないから諦めよう"
emoji: "🐷"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nodejs", "promise", "generator"]
published: false
---

こんなエラーを経験した
UnhandledPromiseRejectionWarning
ハンドルされてないPromiseのRejectがあるぞっていう警告
```bash
(node:29591) UnhandledPromiseRejectionWarning: ReferenceError: e is not defined
    at /Users/nakamurashunsuke/docs/10_project/the-harmony/10_cmm/comomon-api-server-ts/src/models/BaseFileReader.ts:44:33
(Use `node --trace-warnings ...` to show where the warning was created)
(node:29591) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)
(node:29591) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
```

ハンドルするってことはキャッチしたエラーをどこにもthrowせずに何かしらの処理をすること
```typescript
const alwaysRejectFunc = () => {
  return new Promise((_, reject) => {
    return reject('○○失敗')
  })
}

// rejectをハンドルしてる
try {
    (async () => {
      await alwaysRejectFunc()
    })()
    (async () => {
      await alwaysRejectFunc()
    })()
} catch(err) {
    console.log('問題発生！', err)
};

// rejectをハンドルしてない
try {
    (async () => {
      await alwaysRejectFunc()
    })()
    (async () => {
      await alwaysRejectFunc()
    })()
} catch(err) {
    throw new Error('問題発生！', err)
};
```

今回私が遭遇したエラーはこんな処理から発生してた

非同期処理内からthrowしても外側でキャッチできないらしい
setIntervalの外にthrowできておらず、try catchからエラーが見えてない状態
```typescript
      try {
        setInterval(() => {
            (async (): Promise<void> => await read())().catch(error => {
                throw new Error(error);
            });
        }, 600000);
      } catch(e) {
          logger.system.error('ファイル読み込みの定期実行でエラーが発生しました。', error);
      }
```

こうするしかない
```typescript
        setInterval(() => {
            (async (): Promise<void> => await read())().catch(error => {
                logger.system.error('ファイル読み込みの定期実行でエラーが発生しました。', error);
            });
        }, 600000);
```


## 試行錯誤したけどダメだったやつ

### promise

setIntervalの初回のエラーはキャッチできるが、2回目移行はできない
```typescript
function async createInterval(interval: number): Promise<void> {
		await readInterval(interval);
}

// 定期読み込み
function readInterval(interval: number): Promise<void> {
	return new Promise((resolve, reject) => {
     setInterval(() => {
        (async (): Promise<void> => {
						this.read()
						resolve()
				)().catch(e => {
            reject(e);
        });
    }, interval);
	})
}
```

### generator
generatorのthrowなので拾えると思ったけどダメだった
```typescript
async function createInterval(interval: number): Promise<void> {
    this.readGenerator(interval).next() // ここから上にthrowしてほしい！ → だめだった
}

function * readGenerator(interval: number): Generator<NodeJS.Timer> {
    yield this.readInterval(interval, this.readGenerator());
}

// 定期読み込み
function readInterval(interval,: number, generator: Generator<NodeJS.Timer>): NodeJS.Timer {
    return setInterval(() => {
        (async (): Promise<void> =>  this.read())().catch(e => {
            generator.throw(e);
        });
    }, interval);
}
```

## generator参考記事
[How can I write a generator in a JavaScript class?](https://stackoverflow.com/questions/39197811/how-can-i-write-a-generator-in-a-javascript-class)
[JavaScriptと非同期のエラー処理](https://techblog.yahoo.co.jp/programming/javascript_error/)

